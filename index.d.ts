/* auto-generated by NAPI-RS */
/* eslint-disable */
/** Codec configuration options */
export interface CodecOptions {
  codecName?: string
  bitRate?: number
  width?: number
  height?: number
  frameRate?: number
  sampleRate?: number
  channels?: number
  gopSize?: number
  maxBFrames?: number
  crf?: number
  preset?: string
  tune?: string
  profile?: string
  level?: number
}

/** Filter configuration */
export interface FilterConfig {
  filterString: string
}

/** Media container format information */
export interface FormatInfo {
  name: string
  longName: string
  duration?: number
  bitRate?: number
  startTime?: number
  nbStreams: number
}

/**
 * Get media information from a file
 *
 * This is a placeholder implementation. The actual implementation would use
 * av-format and av-data crates to read media files and extract metadata.
 */
export declare function getMediaInfo(path: string): MediaInfo

/** Get media info summary */
export declare function getMediaSummary(path: string): string

/**
 * Get supported codecs
 *
 * Returns a list of codecs supported by Rust-AV ecosystem.
 */
export declare function getSupportedCodecs(): Array<string>

/**
 * Get supported formats
 *
 * Returns a list of container formats supported by Rust-AV ecosystem.
 */
export declare function getSupportedFormats(): Array<string>

/**
 * Get supported pixel formats
 *
 * Returns a list of pixel formats supported by v_frame.
 */
export declare function getSupportedPixelFormats(): Array<string>

/**
 * Get supported sample formats
 *
 * Returns a list of audio sample formats supported by av-data.
 */
export declare function getSupportedSampleFormats(): Array<string>

/** Complete media information */
export interface MediaInfo {
  format: FormatInfo
  streams: Array<StreamInfo>
}

/** Media processing result */
export interface MediaProcessingResult {
  success: boolean
  message: string
  format?: string
  codec?: string
}

/** Progress callback data */
export interface ProgressData {
  currentTime: number
  totalTime: number
  percentage: number
  fps?: number
  bitRate?: number
  size: number
}

/** Media stream information */
export interface StreamInfo {
  index: number
  codecType: string
  codecName: string
  bitRate?: number
  width?: number
  height?: number
  frameRate?: number
  sampleRate?: number
  channels?: number
  duration?: number
}

/**
 * Transcode media file
 *
 * This is a placeholder implementation. The actual implementation would use
 * av-format, av-data, and v_frame crates to perform transcoding.
 */
export declare function transcode(options: TranscodeOptions): void

/** Transcoding options */
export interface TranscodeOptions {
  inputPath: string
  outputPath: string
  videoCodec?: CodecOptions
  audioCodec?: CodecOptions
  videoFilter?: FilterConfig
  audioFilter?: FilterConfig
  format?: string
  startTime?: number
  duration?: number
  seekTo?: number
}

/** Validate media file */
export declare function validateMediaFile(path: string): MediaProcessingResult
